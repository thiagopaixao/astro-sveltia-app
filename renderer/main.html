<!DOCTYPE html>
<html class="dark" lang="pt-BR"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Documental</title>
<link href="./assets/css/fonts.css" rel="stylesheet"/>
<link href="./assets/css/compiled.css" rel="stylesheet"/>
<script defer src="./assets/js/alpine.min.js"></script>
<script src="script.js" defer></script>
<style>
        body {
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .resize-handle {
            cursor: col-resize;
            width: 4px;
            background-color: #4a5568;
            flex-shrink: 0;
        }
        .resize-handle:hover,
        .resize-handle-active {
            background-color: #22c55e;
        }
        .resize-handle-horizontal {
            cursor: row-resize;
            height: 4px;
            background-color: #4a5568;
            flex-shrink: 0;
        }
        .resize-handle-horizontal:hover,
        .resize-handle-horizontal-active {
            background-color: #22c55e;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }
        .initial-loader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .initial-loader__dot {
            width: 12px;
            height: 12px;
            border-radius: 9999px;
            background: #22c55e;
            opacity: 0.2;
            animation: loaderPulse 1.2s ease-in-out infinite;
        }
        .initial-loader__dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .initial-loader__dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes loaderPulse {
            0%, 60%, 100% {
                opacity: 0.2;
                transform: scale(0.9);
            }
            30% {
                opacity: 1;
                transform: scale(1.1);
            }
        }
        [x-cloak] {
            display: none !important;
        }
        .content-loader {
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
<script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#22c55e",
                        "background-light": "#f3f4f6",
                        "background-dark": "#111827",
                        "surface-light": "#ffffff",
                        "surface-dark": "#1f2937",
                        "text-light": "#111827",
                        "text-dark": "#f9fafb",
                        "muted-light": "#6b7280",
                        "muted-dark": "#9ca3af",
                        "accent-orange": "#ff5722",
                    },
                },
            },
        };
    </script>
</head>
<body :class="{'resizing': isResizing || isResizingVertical}" @mousemove.window="onResize($event)" @mouseup.window="stopResize()" class="bg-background-dark text-text-dark antialiased">
<div class="flex flex-col h-screen" x-data="{ 
    menuOpen: false, 
    activeTab: 'view', 
    editorWidth: 50,
    mainHeight: 70,
    consoleOpen: false,
    consoleTabs: [
        {id: 1, name: 'Log', type: 'log'}, 
        {id: 2, name: 'Servidor', type: 'server'}, 
        {id: 3, name: 'Comandos', type: 'commands'}
    ],
    activeConsoleTab: 1,
    nextTerminalId: 1,
    appLogOutput: sessionStorage.getItem('appLogOutput') || '',
    serverOutput: sessionStorage.getItem('serverOutput') || '',
    commandOutput: sessionStorage.getItem('commandOutput') || '',
    addressValue: 'https://documental.xyz/',
    baseURL: 'https://documental.xyz/',
    viewerUrl: null,
    editorUrl: null,
    isResizing: false,
    isResizingVertical: false,
    publishModalOpen: false,
    branchModalOpen: false,
    updateModalOpen: false,
    clearCacheModalOpen: false,
clearingCache: false,
    helpModalOpen: false,
    aboutModalOpen: false,
    exitModalOpen: false,
    isExitingProgrammatically: false,
    selectedBranch: 'stage',
    newBranchName: '',
    currentBranch: 'stage',
    branchAction: 'change',
    branches: [],
     branchLoading: false,
     copySuccess: false,
     // Pull and push functionality
     remoteBranches: [],
     selectedPublishBranch: 'preview',
     pullLoading: false,
     pushLoading: false,
     initialLoading: true,
     contentLoading: false,
     contentReady: false,
     viewerLoaded: false,
     editorLoaded: false,
    devServerUrl: 'https://documental.xyz/', // Default fallback
    viewerScreenshot: null,
    editorScreenshot: null,
    overlaySequence: 0,
    // Repository information
    repoInfo: {
        workingDirectory: '',
        remoteUrl: '',
        lastCommit: {
            hash: '',
            message: '',
            date: null
        }
    },
    repoInfoLoading: false,
    getDevServerUrl() {
        return this.devServerUrl || sessionStorage.getItem('devServerUrl') || this.baseURL;
    },
    get isAnyOverlayOpen() {
        return this.menuOpen || this.publishModalOpen || this.branchModalOpen || this.updateModalOpen || this.clearCacheModalOpen || this.helpModalOpen || this.aboutModalOpen || this.exitModalOpen;
    },
    startResize(event) {
        this.isResizing = true;
        event.target.classList.add('resize-handle-active');
    },
    stopResize() {
        if (this.isResizing) {
           this.$refs.resizeHandle.classList.remove('resize-handle-active');
        }
        if (this.isResizingVertical) {
           this.$refs.resizeHandleHorizontal.classList.remove('resize-handle-horizontal-active');
        }
        this.isResizing = false;
        this.isResizingVertical = false;
    },
    onResize(event) {
        if (this.isResizing) {
            const totalWidth = this.$refs.splitContainer.offsetWidth;
            const newEditorWidth = event.clientX - this.$refs.splitContainer.offsetLeft;
            this.editorWidth = (newEditorWidth / totalWidth) * 100;
        }
        if (this.isResizingVertical) {
            const totalHeight = this.$refs.mainContainer.offsetHeight;
            const newMainHeight = event.clientY - this.$refs.mainContainer.offsetTop;
            this.mainHeight = (newMainHeight / totalHeight) * 100;
        }
    },
    startVerticalResize(event) {
        this.isResizingVertical = true;
        event.target.classList.add('resize-handle-horizontal-active');
    },
    handleAddressInput(event) {
        if (!event.target.value.startsWith(this.baseURL)) {
             event.target.value = this.baseURL;
        }
        this.addressValue = event.target.value;
    },
     handleAddressClick(event) {
        if (event.target.selectionStart < this.baseURL.length) {
            event.target.setSelectionRange(this.baseURL.length, this.baseURL.length);
        }
    },
    handleAddressKeyDown(event) {
        if (event.target.selectionStart < this.baseURL.length && (event.key === 'Backspace' || event.key === 'Delete')) {
           event.preventDefault();
        }
    },
    handleAddressEnter(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            const normalized = event.target.value.trim();
            if (normalized !== this.addressValue) {
                this.addressValue = normalized;
            }
            if (this.addressValue !== this.viewerUrl) {
                this.loadViewer(this.addressValue);
            }
        }
    },
    copyAddress() {
        navigator.clipboard.writeText(this.addressValue).then(() => {
            this.copySuccess = true;
            setTimeout(() => { this.copySuccess = false; }, 2000);
        });
    },
    async confirmClearCache() {
        this.clearingCache = true;
        this.clearCacheModalOpen = false;
        this.menuOpen = false;
        
        try {
            // Clear cache using the new API
            const result = await window.electronAPI.clearBrowserCache();
            
            if (result && result.success) {
                // Reload both BrowserViews with fresh content
                const devServerUrl = this.getDevServerUrl();
                this.addressValue = devServerUrl;
                this.baseURL = devServerUrl;
                
                // Show loading state during reload
                this.initialLoading = true;
                this.contentLoading = false;
                this.contentReady = false;
                this.viewerLoaded = false;
                this.editorLoaded = false;
                
                this.loadViewer(devServerUrl, true);
                this.loadEditor(`${devServerUrl}admin/index.html`, true);
            } else {
                alert('Erro ao limpar cache: ' + (result?.error || 'Erro desconhecido'));
            }
        } catch (error) {
            console.error('Error clearing cache:', error);
            alert('Erro ao limpar cache: ' + error.message);
        } finally {
            this.clearingCache = false;
        }
    },
    async getCurrentWindowState() {
        try {
            const editorUrl = await window.electronAPI.getBrowserViewUrl('editor');
            const viewerUrl = await window.electronAPI.getBrowserViewUrl('view');
            
            // Simplify consoleTabs to only serializable data
            const simplifiedConsoleTabs = this.consoleTabs.map(tab => ({
                id: tab.id,
                name: tab.name,
                type: tab.type
            }));
            
            // Limit output size to prevent IPC issues (last 5000 characters each)
            const maxOutputLength = 5000;
            const truncatedAppLogOutput = this.appLogOutput.length > maxOutputLength 
                ? this.appLogOutput.slice(-maxOutputLength) 
                : this.appLogOutput;
            const truncatedServerOutput = this.serverOutput.length > maxOutputLength 
                ? this.serverOutput.slice(-maxOutputLength) 
                : this.serverOutput;
            const truncatedCommandOutput = this.commandOutput.length > maxOutputLength 
                ? this.commandOutput.slice(-maxOutputLength) 
                : this.commandOutput;
            
            const windowState = {
                editorUrl: editorUrl || `${this.getDevServerUrl()}admin/index.html`,
                viewerUrl: viewerUrl || this.getDevServerUrl(),
                addressValue: this.addressValue,
                baseURL: this.baseURL,
                devServerUrl: this.getDevServerUrl(),
                activeTab: this.activeTab,
                editorWidth: this.editorWidth,
                mainHeight: this.mainHeight,
                consoleOpen: this.consoleOpen,
                currentBranch: this.currentBranch,
                appLogOutput: truncatedAppLogOutput,
                serverOutput: truncatedServerOutput,
                commandOutput: truncatedCommandOutput,
                consoleTabs: simplifiedConsoleTabs,
                activeConsoleTab: this.activeConsoleTab,
                nextTerminalId: this.nextTerminalId
            };
            
            // Test if the object is serializable before sending
            try {
                JSON.stringify(windowState);
                return windowState;
            } catch (serializationError) {
                console.error('Window state serialization failed:', serializationError);
                // Return minimal state if serialization fails
                return {
                    editorUrl: editorUrl || `${this.getDevServerUrl()}admin/index.html`,
                    viewerUrl: viewerUrl || this.getDevServerUrl(),
                    addressValue: this.addressValue,
                    baseURL: this.baseURL,
                    devServerUrl: this.getDevServerUrl(),
                    activeTab: this.activeTab,
                    editorWidth: this.editorWidth,
                    mainHeight: this.mainHeight,
                    consoleOpen: this.consoleOpen,
                    currentBranch: this.currentBranch,
                    appLogOutput: sessionStorage.getItem('appLogOutput') || '',
                    serverOutput: sessionStorage.getItem('serverOutput') || '',
                    commandOutput: sessionStorage.getItem('commandOutput') || '',
                    consoleTabs: [
                        {id: 1, name: 'Log', type: 'log'}, 
                        {id: 2, name: 'Servidor', type: 'server'}, 
                        {id: 3, name: 'Comandos', type: 'commands'}
                    ],
                    activeConsoleTab: 1,
                    nextTerminalId: 1
                };
            }
        } catch (error) {
            console.error('Error getting window state:', error);
            return null;
        }
    },
    async openNewWindow() {
        try {
            const windowState = await this.getCurrentWindowState();
            if (windowState) {
                console.log('Opening new window with state:', windowState);
                const result = await window.electronAPI.createNewWindowWithState(windowState);
                if (!result.success) {
                    throw new Error(result.error || 'Unknown error occurred');
                }
            } else {
                throw new Error('Failed to capture window state');
            }
        } catch (error) {
            console.error('Error opening new window:', error);
            alert('Erro ao abrir nova janela: ' + error.message);
        }
        this.menuOpen = false;
    },
    exitApp() {
        console.log('exitApp() called - requesting exit confirmation from main process');
        if (window.electronAPI && window.electronAPI.confirmExitApp) {
            window.electronAPI.confirmExitApp();
        } else {
            console.error('electronAPI.confirmExitApp not available');
            window.close();
        }
    },
    confirmExit() {
        console.log('confirmExit() called - setting programmatic exit flag and sending confirmation to main process');
        this.exitModalOpen = false;
        this.isExitingProgrammatically = true; // Set flag to prevent beforeunload from showing dialog again
        
        if (window.electronAPI && window.electronAPI.sendExitConfirmationResponse) {
            window.electronAPI.sendExitConfirmationResponse(true);
        } else {
            console.error('electronAPI.sendExitConfirmationResponse not available');
            window.close();
        }
    },
    cancelExit() {
        console.log('cancelExit() called - resetting programmatic exit flag and sending cancellation to main process');
        this.exitModalOpen = false;
        this.isExitingProgrammatically = false; // Reset flag since user cancelled
        
        if (window.electronAPI && window.electronAPI.sendExitConfirmationResponse) {
            window.electronAPI.sendExitConfirmationResponse(false);
        }
    },
    addTerminalTab() {
        const newId = Date.now();
        this.consoleTabs.push({ id: newId, name: `Terminal ${this.nextTerminalId}`, type: 'terminal' });
        this.activeConsoleTab = newId;
        this.nextTerminalId++;
        if(!this.consoleOpen) {
            this.consoleOpen = true;
            this.mainHeight = 70;
        }
        // Scroll to bottom after adding tab
        this.$nextTick(() => {
            this.scrollToBottomOfActiveConsole();
        });
    },
    closeConsoleTab(tabId, event) {
        event.stopPropagation();
        const index = this.consoleTabs.findIndex(tab => tab.id === tabId);
        if (index > -1) {
            this.consoleTabs.splice(index, 1);
            if (this.activeConsoleTab === tabId && this.consoleTabs.length > 0) {
                 this.activeConsoleTab = this.consoleTabs[Math.max(0, index - 1)].id;
            } else if (this.consoleTabs.length === 0) {
                this.consoleOpen = false;
            }
        }
    },

    scrollToBottomOfActiveConsole() {
        if (this.$refs.consoleContainer) {
            const activeTabElement = this.$refs.consoleContainer.querySelector('.overflow-y-auto');
            if (activeTabElement) {
                activeTabElement.scrollTop = activeTabElement.scrollHeight;
            }
        }
    },
    scrollToTopOfActiveConsole() {
        if (this.$refs.consoleContainer) {
            const activeTabElement = this.$refs.consoleContainer.querySelector('.overflow-y-auto');
            if (activeTabElement) {
                activeTabElement.scrollTop = 0;
            }
        }
    },
    getWorkingBranchName() {
        const date = new Date();
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `working_user_${year}${month}${day}-${hours}${minutes}_`;
    },
    async loadBranches() {
        const projectId = sessionStorage.getItem('currentProjectId');
        console.log('ðŸ” loadBranches called');
        console.log('- projectId from sessionStorage:', projectId);
        console.log('- window.electronAPI available:', !!window.electronAPI);
        console.log('- listBranches method available:', !!(window.electronAPI && window.electronAPI.listBranches));
        
        if (!projectId) {
            console.warn('âŒ No project ID found, cannot load branches');
            return;
        }
        
        this.branchLoading = true;
        try {
            console.log('ðŸ“¡ Calling window.electronAPI.listBranches with projectId:', projectId);
            const result = await window.electronAPI.listBranches(projectId);
            console.log('ðŸ“¥ Raw result from IPC:', result);
            
            if (result.success) {
                console.log('âœ… IPC call successful');
                console.log('- result.branches:', result.branches);
                console.log('- result.currentBranch:', result.currentBranch);
                
                this.branches = result.branches || [];
                this.currentBranch = result.currentBranch;
                this.selectedBranch = result.currentBranch;
                
                console.log('âœ… Branches loaded:', { 
                    branches: this.branches, 
                    current: this.currentBranch,
                    branchesCount: this.branches.length 
                });
                
                // Debug template rendering
                console.log('ðŸŽ¨ Template will render branches:', this.branches.map(b => ({ 
                    name: b.name, 
                    value: b.name, 
                    text: b.name 
                })));
            } else {
                console.error('âŒ Error loading branches:', result.error);
                alert('Erro ao carregar branches: ' + result.error);
            }
        } catch (error) {
            console.error('âŒ Error loading branches:', error);
            console.error('Stack:', error.stack);
            alert('Erro ao carregar branches: ' + error.message);
        } finally {
            this.branchLoading = false;
        }
    },
    async loadRepositoryInfo() {
        const projectId = sessionStorage.getItem('currentProjectId');
        if (!projectId) {
            console.warn('No project ID found, cannot load repository info');
            return;
        }
        
        this.repoInfoLoading = true;
        try {
            const result = await window.electronAPI.getRepositoryInfo(projectId);
            if (result.success) {
                this.repoInfo = {
                    workingDirectory: result.workingDirectory || '',
                    remoteUrl: result.remoteUrl || '',
                    lastCommit: {
                        hash: result.lastCommit?.hash || '',
                        message: result.lastCommit?.message || '',
                        date: result.lastCommit?.date ? new Date(result.lastCommit.date) : null
                    }
                };
                console.log('âœ… Repository info loaded:', this.repoInfo);
            } else {
                console.error('âŒ Error loading repository info:', result.error);
                // Don't show alert for repository info errors to avoid spam
            }
        } catch (error) {
            console.error('âŒ Error loading repository info:', error);
        } finally {
            this.repoInfoLoading = false;
        }
    },
    formatCommitDate(date) {
        if (!date) return '';
        const day = String(date.getDate()).padStart(2, '0');
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const year = date.getFullYear();
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${day}/${month}/${year} ${hours}:${minutes}`;
    },
    getRepoNameFromUrl(url) {
        if (!url) return '';
        try {
            // Extract owner/repo from GitHub URL
            const match = url.match(/github\.com[\/:]([^\/]+)\/([^\/\.]+)(\.git)?$/);
            if (match) {
                return `${match[1]}/${match[2]}`;
            }
            return url;
        } catch (error) {
            return url;
        }
    },
    async openProjectDirectory() {
        if (!this.repoInfo.workingDirectory) return;
        try {
            await window.electronAPI.openInFileExplorer(this.repoInfo.workingDirectory);
        } catch (error) {
            console.error('Error opening project directory:', error);
        }
    },
    async changeBranch() {
        const projectId = sessionStorage.getItem('currentProjectId');
        if (!projectId || !this.selectedBranch) {
            return;
        }
        
        if (this.selectedBranch === this.currentBranch) {
            console.log('Already on selected branch, no action needed');
            return;
        }
        
        try {
            const result = await window.electronAPI.checkoutBranch(projectId, this.selectedBranch);
            if (result.success) {
                this.currentBranch = this.selectedBranch;
                console.log('âœ… Changed to branch:', this.currentBranch);
                // Optionally reload branches to update state
                await this.loadBranches();
                // Refresh repository info after branch change
                await this.loadRepositoryInfo();
            } else {
                console.error('âŒ Error changing branch:', result.error);
                alert('Erro ao mudar de branch: ' + result.error);
            }
        } catch (error) {
            console.error('âŒ Error changing branch:', error);
            alert('Erro ao mudar de branch: ' + error.message);
        }
    },
    async createBranch() {
        const projectId = sessionStorage.getItem('currentProjectId');
        if (!projectId || !this.newBranchName.trim()) {
            alert('Por favor, informe um nome para a nova branch');
            return;
        }
        
        const fullName = this.getWorkingBranchName() + this.newBranchName.trim();
        
        try {
            const result = await window.electronAPI.createBranch(projectId, fullName);
            if (result.success) {
                this.currentBranch = fullName;
                this.selectedBranch = fullName;
                this.newBranchName = '';
                this.branchAction = 'change'; // Switch back to change mode
                console.log('âœ… Created and switched to branch:', this.currentBranch);
                // Reload branches to update the list
                await this.loadBranches();
                // Refresh repository info after branch creation
                await this.loadRepositoryInfo();
            } else {
                console.error('âŒ Error creating branch:', result.error);
                alert('Erro ao criar branch: ' + result.error);
            }
        } catch (error) {
            console.error('âŒ Error creating branch:', error);
            alert('Erro ao criar branch: ' + error.message);
        }
    },
    async loadRemoteBranches() {
        const projectId = sessionStorage.getItem('currentProjectId');
        if (!projectId) {
            console.warn('No project ID found, cannot load remote branches');
            return;
        }
        
        try {
            const result = await window.electronAPI.listRemoteBranches(projectId);
            if (result.success) {
                this.remoteBranches = result.branches;
                this.selectedPublishBranch = result.defaultBranch || 'preview';
                console.log('âœ… Remote branches loaded:', { branches: this.remoteBranches, default: this.selectedPublishBranch });
            } else {
                console.error('âŒ Error loading remote branches:', result.error);
                alert('Erro ao carregar branches remotas: ' + result.error);
            }
        } catch (error) {
            console.error('âŒ Error loading remote branches:', error);
            alert('Erro ao carregar branches remotas: ' + error.message);
        }
    },
    async pullFromPreview() {
        const projectId = sessionStorage.getItem('currentProjectId');
        if (!projectId) {
            console.warn('No project ID found, cannot pull from preview');
            return;
        }
        
        this.pullLoading = true;
        this.updateModalOpen = false;
        
        try {
            const result = await window.electronAPI.pullFromPreview(projectId);
            if (result.success) {
                console.log('âœ… Pull from preview successful:', result.message);
                alert('âœ… ' + result.message);
                // Refresh repository info after pull
                await this.loadRepositoryInfo();
                // Reload branches to update state
                await this.loadBranches();
            } else {
                console.error('âŒ Error pulling from preview:', result.error);
                alert('âŒ Erro ao atualizar: ' + result.error);
            }
        } catch (error) {
            console.error('âŒ Error pulling from preview:', error);
            alert('âŒ Erro ao atualizar: ' + error.message);
        } finally {
            this.pullLoading = false;
        }
    },
    async pushToBranch() {
        const projectId = sessionStorage.getItem('currentProjectId');
        if (!projectId) {
            console.warn('No project ID found, cannot push to branch');
            return;
        }
        
        if (!this.selectedPublishBranch) {
            alert('Por favor, selecione uma branch para publicar.');
            return;
        }
        
        this.pushLoading = true;
        this.publishModalOpen = false;
        
        try {
            const result = await window.electronAPI.pushToBranch(projectId, this.selectedPublishBranch);
            if (result.success) {
                console.log('âœ… Push to branch successful:', result.message);
                alert('âœ… ' + result.message);
                // Refresh repository info after push
                await this.loadRepositoryInfo();
            } else {
                console.error('âŒ Error pushing to branch:', result.error);
                alert('âŒ Erro ao publicar: ' + result.error);
            }
        } catch (error) {
            console.error('âŒ Error pushing to branch:', error);
            alert('âŒ Erro ao publicar: ' + error.message);
        } finally {
            this.pushLoading = false;
        }
    },
    async init() { // Make init an async function
        console.log('ðŸš€ INIT STARTED - Renderer initialization beginning');
        
        // Check project context immediately
        const currentProjectId = sessionStorage.getItem('currentProjectId');
        console.log('ðŸ” PROJECT CONTEXT CHECK - currentProjectId:', currentProjectId);
        console.log('ðŸ” All sessionStorage keys:', Object.keys(sessionStorage));
        
        console.log('ðŸ“Š Initial Alpine.js state:', {
            initialLoading: this.initialLoading,
            contentLoading: this.contentLoading,
            contentReady: this.contentReady,
            viewerLoaded: this.viewerLoaded,
            editorLoaded: this.editorLoaded,
            currentProjectId: currentProjectId
        });
        
        // Check if this window was opened with state parameters
        const urlParams = new URLSearchParams(window.location.search);
        const stateParam = urlParams.get('state');
        console.log('ðŸ” URL params check - stateParam:', stateParam);
        
        if (stateParam) {
            try {
                // Decode and apply the window state
                const windowState = JSON.parse(atob(stateParam));
                console.log('Applying window state from URL:', windowState);
                this.applyWindowState(windowState);
            } catch (error) {
                console.error('Error parsing window state:', error);
                // Fall back to normal initialization
            }
        }

        // Listen for dev-server-url events from main process FIRST
        console.log('Setting up dev-server-url listener...');
        window.electronAPI.onDevServerUrl((devServerUrl) => {
            console.log('ðŸŽ¯ EVENT RECEIVED - dev server URL:', devServerUrl);
            console.log('Current devServerUrl before update:', this.devServerUrl);
            if (devServerUrl && devServerUrl !== this.devServerUrl) {
                console.log('ðŸ”„ UPDATING URLs with dev server URL');
                this.devServerUrl = devServerUrl;
                sessionStorage.setItem('devServerUrl', devServerUrl);
                
                // Update URL variables
                this.baseURL = devServerUrl;
                this.addressValue = devServerUrl;
                this.viewerUrl = devServerUrl;
                this.editorUrl = `${devServerUrl}admin/index.html`;
                
                // Reload BrowserViews with the correct URLs
                this.loadViewer(devServerUrl, true);
                this.loadEditor(`${devServerUrl}admin/index.html`, true);
                
                console.log('âœ… Updated all URLs to dev server:', {
                    devServerUrl: this.devServerUrl,
                    baseURL: this.baseURL,
                    addressValue: this.addressValue,
                    viewerUrl: this.viewerUrl,
                    editorUrl: this.editorUrl
                });
            } else {
                console.log('âš ï¸ URL not updated - devServerUrl:', devServerUrl, 'current:', this.devServerUrl);
            }
        });

        // Set up listeners for new console output channels
        window.electronAPI.onAppLogOutput((output) => {
            this.appLogOutput += output;
            // Persist to sessionStorage
            sessionStorage.setItem('appLogOutput', this.appLogOutput);
            // Trigger UI update with auto-scroll if this tab is active
            this.$nextTick(() => {
                const activeTab = this.consoleTabs.find(tab => tab.id === this.activeConsoleTab);
                if (activeTab && activeTab.type === 'log') {
                    this.scrollToBottomOfActiveConsole();
                }
            });
        });

        window.electronAPI.onServerOutput((output) => {
            this.serverOutput += output;
            // Persist to sessionStorage
            sessionStorage.setItem('serverOutput', this.serverOutput);
            // Trigger UI update with auto-scroll if this tab is active
            this.$nextTick(() => {
                const activeTab = this.consoleTabs.find(tab => tab.id === this.activeConsoleTab);
                if (activeTab && activeTab.type === 'server') {
                    this.scrollToBottomOfActiveConsole();
                }
            });
        });

        window.electronAPI.onCommandOutput((output) => {
            this.commandOutput += output;
            // Persist to sessionStorage
            sessionStorage.setItem('commandOutput', this.commandOutput);
            // Trigger UI update with auto-scroll if this tab is active
            this.$nextTick(() => {
                const activeTab = this.consoleTabs.find(tab => tab.id === this.activeConsoleTab);
                if (activeTab && activeTab.type === 'commands') {
                    this.scrollToBottomOfActiveConsole();
                }
            });
        });

        // Load initial app logs and restore from sessionStorage
        window.electronAPI.getAppLogs().then(initialLogs => {
            if (initialLogs) {
                this.appLogOutput = initialLogs;
                // Update sessionStorage with the latest from main process
                sessionStorage.setItem('appLogOutput', this.appLogOutput);
            }
        }).catch(error => {
            console.error('Error loading initial app logs:', error);
        });

        // Always restore content from sessionStorage to ensure we have the latest data
        const storedAppLogs = sessionStorage.getItem('appLogOutput') || '';
        const storedServerOutput = sessionStorage.getItem('serverOutput') || '';
        const storedCommandOutput = sessionStorage.getItem('commandOutput') || '';
        
        // Only update if stored content is longer (has more data)
        if (storedAppLogs.length > this.appLogOutput.length) {
            this.appLogOutput = storedAppLogs;
            console.log('ðŸ“¦ Restored app logs from sessionStorage:', storedAppLogs.length, 'characters');
        }
        if (storedServerOutput.length > this.serverOutput.length) {
            this.serverOutput = storedServerOutput;
            console.log('ðŸ“¦ Restored server output from sessionStorage:', storedServerOutput.length, 'characters');
        }
        if (storedCommandOutput.length > this.commandOutput.length) {
            this.commandOutput = storedCommandOutput;
            console.log('ðŸ“¦ Restored command output from sessionStorage:', storedCommandOutput.length, 'characters');
        }

        // Always try to get devServerUrl from main process first
        console.log('ðŸ” Checking devServerUrl - current value:', this.devServerUrl);
        console.log('ðŸ“¡ Calling getDevServerUrlFromMain...');
        const devServerUrl = await window.electronAPI.getDevServerUrlFromMain();
        console.log('ðŸ“¡ getDevServerUrlFromMain returned:', devServerUrl);
        
        if (devServerUrl) {
            this.devServerUrl = devServerUrl;
            sessionStorage.setItem('devServerUrl', devServerUrl);
            console.log('âœ… Set devServerUrl from main process:', devServerUrl);
        } else {
            const storedUrl = sessionStorage.getItem('devServerUrl');
            console.log('ðŸ’¾ Checking sessionStorage - storedUrl:', storedUrl);
            if (storedUrl) {
                this.devServerUrl = storedUrl;
                console.log('âœ… Set devServerUrl from sessionStorage:', storedUrl);
            } else {
                console.log('âŒ No devServerUrl found anywhere!');
                alert('Erro: URL do servidor de desenvolvimento nÃ£o encontrada. Por favor, inicie o projeto novamente.');
                return;
            }
        }

        // Set default values ONLY if not already set by window state
        // This prevents overwriting the captured state
        console.log('ðŸ”§ Setting default URL values - devServerUrl:', this.devServerUrl);
        console.log('Before update - addressValue:', this.addressValue, 'baseURL:', this.baseURL, 'viewerUrl:', this.viewerUrl, 'editorUrl:', this.editorUrl);
        
        if (!this.addressValue || this.addressValue === 'https://documental.xyz/') {
            this.addressValue = this.devServerUrl;
            console.log('âœ… Updated addressValue to:', this.addressValue);
        }
        if (!this.baseURL || this.baseURL === 'https://documental.xyz/') {
            this.baseURL = this.devServerUrl;
            console.log('âœ… Updated baseURL to:', this.baseURL);
        }
        if (!this.viewerUrl) {
            this.viewerUrl = this.devServerUrl;
            console.log('âœ… Updated viewerUrl to:', this.viewerUrl);
        }
        if (!this.editorUrl) {
            this.editorUrl = `${this.devServerUrl}admin/index.html`;
            console.log('âœ… Updated editorUrl to:', this.editorUrl);
        }
        
        console.log('After update - addressValue:', this.addressValue, 'baseURL:', this.baseURL, 'viewerUrl:', this.viewerUrl, 'editorUrl:', this.editorUrl);
        
        console.log('Final initialization values:', {
            addressValue: this.addressValue,
            baseURL: this.baseURL,
            viewerUrl: this.viewerUrl,
            editorUrl: this.editorUrl,
            devServerUrl: this.devServerUrl
        });

        // Wait a moment for DOM to be fully ready before loading BrowserViews
        await new Promise(resolve => setTimeout(resolve, 100));

        // Initial load of BrowserViews
        console.log('ðŸš€ Initial BrowserView load - viewerUrl:', this.viewerUrl, 'editorUrl:', this.editorUrl);
        console.log('ðŸ“Š Initial loading state:', {
            initialLoading: this.initialLoading,
            contentLoading: this.contentLoading,
            contentReady: this.contentReady,
            viewerLoaded: this.viewerLoaded,
            editorLoaded: this.editorLoaded
        });
        
        // Ensure loading state is properly set before starting
        if (!this.initialLoading) {
            console.log('âš ï¸ initialLoading was false, setting it back to true');
            this.initialLoading = true;
            this.contentLoading = false;
            this.contentReady = false;
            this.viewerLoaded = false;
            this.editorLoaded = false;
        }
        
        this.loadViewer(this.viewerUrl, true);
        this.loadEditor(this.editorUrl, true);
        console.log('âœ… Initial BrowserView load completed');
        console.log('ðŸ“Š Loading state after load:', {
            initialLoading: this.initialLoading,
            contentLoading: this.contentLoading,
            contentReady: this.contentReady,
            viewerLoaded: this.viewerLoaded,
            editorLoaded: this.editorLoaded
        });

        // Set initial visibility and bounds
        this.$nextTick(() => {
            this.updateBrowserViewBounds();
            this.updateBrowserViewVisibility();
        });

        // Watch for changes in activeTab to update BrowserView visibility and bounds
        this.$watch('activeTab', (tab) => {
            this.updateBrowserViewVisibility();
            this.$nextTick(() => {
                this.updateBrowserViewBounds();
            });
            if (tab === 'editor') {
                this.updateAddressFromBrowser('editor');
            } else {
                this.updateAddressFromBrowser('view');
            }
        });

        // Watch for changes in consoleOpen or layout-driven values to update bounds once DOM is ready
        this.$watch('consoleOpen', () => {
            this.$nextTick(() => this.updateBrowserViewBounds());
        });
        this.$watch('mainHeight', () => {
            this.$nextTick(() => this.updateBrowserViewBounds());
        });
        this.$watch('editorWidth', () => {
            this.$nextTick(() => this.updateBrowserViewBounds());
        });

        // Watch for overlay toggles to manage BrowserView visibility with previews
        this.$watch('isAnyOverlayOpen', (isOpen) => {
            this.handleOverlayChange(isOpen);
        });

        // Watch for branch modal opening to reload branches
        this.$watch('branchModalOpen', (isOpen) => {
            console.log('ðŸ” branchModalOpen changed to:', isOpen);
            if (isOpen) {
                console.log('ðŸ“‹ Branch modal opened, calling loadBranches()');
                this.loadBranches();
            }
        });

        // Watch for publish modal opening to load remote branches
        this.$watch('publishModalOpen', (isOpen) => {
            if (isOpen) {
                this.loadRemoteBranches();
            }
        });

        // Watch for console tab changes to scroll to bottom when switching tabs
        this.$watch('activeConsoleTab', () => {
            this.$nextTick(() => {
                this.scrollToBottomOfActiveConsole();
            });
        });

        window.addEventListener('resize', () => {
            this.updateBrowserViewBounds();
        });

        if (window.electronAPI && window.electronAPI.onBrowserViewLoaded) {
            window.electronAPI.onBrowserViewLoaded(({ viewName, url }) => {
                console.log(`ðŸŽ¯ BrowserView loaded event received: ${viewName} at ${url}`);
                const target = viewName === 'editor' ? 'editor' : 'view';
                this.updateAddressFromBrowser(target, url);
                this.markViewLoaded(target);
            });
        }

        this.updateAddressFromBrowser('view');

        // Fallback timeout to ensure loading animation doesn't get stuck
        setTimeout(() => {
            if (this.initialLoading || this.contentLoading) {
                console.log('â° Loading timeout - forcing loading to complete');
                this.initialLoading = false;
                this.contentLoading = false;
                this.contentReady = false;
                this.viewerLoaded = true;
                this.editorLoaded = true;
            }
        }, 12000); // 12 seconds fallback (increased for new states)

        // Set up exit confirmation handlers
        if (window.electronAPI && window.electronAPI.onShowExitConfirmation) {
            window.electronAPI.onShowExitConfirmation(() => {
                console.log('Received show exit confirmation event');
                this.exitModalOpen = true;
            });
        }

        // Handle beforeunload event to catch window close attempts
        window.addEventListener('beforeunload', (e) => {
            console.log('beforeunload event triggered, isExitingProgrammatically:', this.isExitingProgrammatically);
            
            // If we're exiting programmatically (after user confirmation), allow it
            if (this.isExitingProgrammatically) {
                console.log('Programmatic exit detected - allowing window to close');
                return true;
            }
            
            // Otherwise, prevent default and show confirmation dialog
            console.log('Manual close attempt detected - showing confirmation');
            e.preventDefault();
            if (window.electronAPI && window.electronAPI.confirmExitApp) {
                window.electronAPI.confirmExitApp();
            }
            return false;
        });

        // Reset flag when window gains focus again (in case user cancelled)
        window.addEventListener('focus', () => {
            if (this.isExitingProgrammatically && this.exitModalOpen === false) {
                console.log('Window regained focus - resetting programmatic exit flag');
                this.isExitingProgrammatically = false;
            }
        });

        // Load project state from sessionStorage to restore command and server outputs
        const projectId = sessionStorage.getItem('currentProjectId');
        if (projectId) {
            console.log('ðŸ”„ Loading project state for projectId:', projectId);
            
            // First try to load from projectCreationState (for create.html flow)
            let savedState = JSON.parse(sessionStorage.getItem(`projectCreationState-${projectId}`));
            
            // If not found, try to load from projectOpenState (for open.html flow)
            if (!savedState) {
                savedState = JSON.parse(sessionStorage.getItem(`projectOpenState-${projectId}`));
            }
            
            if (savedState && savedState.steps) {
                console.log('ðŸ“‹ Processing', savedState.steps.length, 'steps from project state');
                let serverOutputFromState = '';
                let commandOutputFromState = '';
                
                savedState.steps.forEach(step => {
                    if (step.log) {
                        if (step.title.includes('Executando servidor do modo dev')) {
                            serverOutputFromState += step.log + '\n';
                        } else {
                            commandOutputFromState += step.log + '\n';
                        }
                    }
                });
                
                // Append to existing output if it's not already there
                if (serverOutputFromState && !this.serverOutput.includes(serverOutputFromState.trim())) {
                    this.serverOutput += serverOutputFromState;
                    sessionStorage.setItem('serverOutput', this.serverOutput);
                    console.log('ðŸ“¦ Restored server output from project state:', serverOutputFromState.length, 'characters');
                }
                
                if (commandOutputFromState && !this.commandOutput.includes(commandOutputFromState.trim())) {
                    this.commandOutput += commandOutputFromState;
                    sessionStorage.setItem('commandOutput', this.commandOutput);
                    console.log('ðŸ“¦ Restored command output from project state:', commandOutputFromState.length, 'characters');
                }
            }
        }

        // Load branches for the current project
        await this.loadBranches();
        
        // Load repository information
        await this.loadRepositoryInfo();
        
        // Set up periodic refresh for repository info (every 30 seconds)
        setInterval(async () => {
            if (sessionStorage.getItem('currentProjectId')) {
                await this.loadRepositoryInfo();
            }
        }, 30000);
    },
    applyWindowState(windowState) {
        console.log('Applying window state:', windowState);
        
        // Apply the captured window state to this window
        // Only apply if the value exists and is not the default
        if (windowState.editorUrl && windowState.editorUrl !== 'https://documental.xyz/admin/index.html') {
            this.editorUrl = windowState.editorUrl;
        }
        if (windowState.viewerUrl && windowState.viewerUrl !== 'https://documental.xyz/') {
            this.viewerUrl = windowState.viewerUrl;
        }
        if (windowState.addressValue && windowState.addressValue !== 'https://documental.xyz/') {
            this.addressValue = windowState.addressValue;
        }
        if (windowState.baseURL && windowState.baseURL !== 'https://documental.xyz/') {
            this.baseURL = windowState.baseURL;
        }
        if (windowState.devServerUrl && windowState.devServerUrl !== 'https://documental.xyz/') {
            this.devServerUrl = windowState.devServerUrl;
        }
        if (windowState.activeTab) this.activeTab = windowState.activeTab;
        if (windowState.editorWidth) this.editorWidth = windowState.editorWidth;
        if (windowState.mainHeight) this.mainHeight = windowState.mainHeight;
        if (windowState.consoleOpen !== undefined) this.consoleOpen = windowState.consoleOpen;
        if (windowState.currentBranch) this.currentBranch = windowState.currentBranch;
        if (windowState.appLogOutput) this.appLogOutput = windowState.appLogOutput;
        if (windowState.serverOutput) this.serverOutput = windowState.serverOutput;
        if (windowState.commandOutput) this.commandOutput = windowState.commandOutput;
        if (windowState.consoleTabs) this.consoleTabs = windowState.consoleTabs;
        if (windowState.activeConsoleTab) this.activeConsoleTab = windowState.activeConsoleTab;
        if (windowState.nextTerminalId) this.nextTerminalId = windowState.nextTerminalId;
        
        // Store devServerUrl in sessionStorage for persistence
        if (windowState.devServerUrl) {
            sessionStorage.setItem('devServerUrl', windowState.devServerUrl);
        }
        
        console.log('State applied. Current values:', {
            addressValue: this.addressValue,
            baseURL: this.baseURL,
            viewerUrl: this.viewerUrl,
            editorUrl: this.editorUrl,
            devServerUrl: this.devServerUrl
        });
    },
    loadViewer(url, force = false) {
        if (!url) {
            return;
        }
        if (!force && url === this.viewerUrl) {
            return;
        }
        console.log(`ðŸ”— loadViewer called with URL: ${url}, force: ${force}`);
        this.viewerUrl = url;
        window.electronAPI.loadBrowserViewUrl('view', url);
        if (this.activeTab !== 'editor') {
            this.addressValue = url;
        }
        if (this.initialLoading || this.contentLoading) {
            this.viewerLoaded = false;
            console.log('ðŸ”„ Viewer loading reset - viewerLoaded set to false');
        }
    },
    loadEditor(url, force = false) {
        if (!url) {
            return;
        }
        if (!force && url === this.editorUrl) {
            return;
        }
        console.log(`ðŸ”— loadEditor called with URL: ${url}, force: ${force}`);
        this.editorUrl = url;
        window.electronAPI.loadBrowserViewUrl('editor', url);
        if (this.activeTab === 'editor') {
            this.addressValue = url;
        }
        if (this.initialLoading || this.contentLoading) {
            this.editorLoaded = false;
            console.log('ðŸ”„ Editor loading reset - editorLoaded set to false');
        }
    },
    getActiveBrowserViewName() {
        return this.activeTab === 'editor' ? 'editor' : 'view';
    },
    async browserGoBack() {
        if (!window.electronAPI || !window.electronAPI.browserViewGoBack) {
            return;
        }
        const target = this.getActiveBrowserViewName();
        try {
            const moved = await window.electronAPI.browserViewGoBack(target);
            if (moved) {
                await this.updateAddressFromBrowser(target);
            }
        } catch (error) {
            console.error('Erro ao acionar voltar:', error);
        }
    },
    async browserReload() {
        if (!window.electronAPI || !window.electronAPI.browserViewReload) {
            return;
        }
        const target = this.getActiveBrowserViewName();
        try {
            const reloaded = await window.electronAPI.browserViewReload(target);
            if (reloaded) {
                await this.updateAddressFromBrowser(target);
            }
        } catch (error) {
            console.error('Erro ao recarregar BrowserView:', error);
        }
    },
    browserGoHome() {
        if (!window.electronAPI) {
            return;
        }
        const target = this.getActiveBrowserViewName();
        if (target === 'editor') {
            const editorHome = `${this.baseURL}admin/index.html`;
            this.addressValue = editorHome;
            this.loadEditor(editorHome, true);
        } else {
            this.addressValue = this.baseURL;
            this.loadViewer(this.baseURL, true);
        }
    },
    async updateAddressFromBrowser(target, urlHint = null) {
        if (!window.electronAPI || !window.electronAPI.getBrowserViewUrl) {
            return;
        }
        try {
            let currentUrl = urlHint;
            if (!currentUrl) {
                currentUrl = await window.electronAPI.getBrowserViewUrl(target);
            }
            if (!currentUrl || currentUrl === 'about:blank') {
                return;
            }
            if (target === 'editor') {
                this.editorUrl = currentUrl;
                if (this.activeTab === 'editor') {
                    this.addressValue = currentUrl;
                }
            } else {
                this.viewerUrl = currentUrl;
                if (this.activeTab !== 'editor') {
                    this.addressValue = currentUrl;
                }
            }
            this.markViewLoaded(target);
        } catch (error) {
            console.error('Erro ao sincronizar endereÃ§o do BrowserView:', error);
        }
    },
    markViewLoaded(target) {
        console.log(`ðŸ“ markViewLoaded called for ${target}. Current state:`, {
            initialLoading: this.initialLoading,
            contentLoading: this.contentLoading,
            contentReady: this.contentReady,
            editorLoaded: this.editorLoaded,
            viewerLoaded: this.viewerLoaded
        });
        
        if (target === 'editor') {
            this.editorLoaded = true;
            console.log('âœ… Editor marked as loaded');
        } else {
            this.viewerLoaded = true;
            console.log('âœ… Viewer marked as loaded');
        }
        
        // Transition to content loading state when first view loads
        if (this.initialLoading && (this.editorLoaded || this.viewerLoaded)) {
            console.log('ðŸ”„ First view loaded - transitioning to content loading');
            this.contentLoading = true;
            this.initialLoading = false;
        }
        
        // Transition to content ready when both views are loaded
        if (this.contentLoading && this.editorLoaded && this.viewerLoaded) {
            console.log('ðŸŽ‰ Both BrowserViews loaded - transitioning to content ready');
            this.contentReady = true;
            
            // Final transition to complete loading after a short delay
            setTimeout(() => {
                console.log('âœ¨ Loading complete - hiding all loading states');
                this.contentLoading = false;
                this.contentReady = false;
            }, 300); // 300ms for smooth transition
        }
    },
    updateBrowserViewBounds() {
        const headerHeight = 64; // matches h-16 header
        const footerHeight = 32; // matches h-8 footer
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        let mainContentTop = headerHeight;
        let mainContentBottom = windowHeight - footerHeight;

        if (this.consoleOpen && this.$refs.consoleContainer) {
            const consoleRect = this.$refs.consoleContainer.getBoundingClientRect();
            mainContentBottom = Math.max(mainContentTop, Math.round(consoleRect.top));
        }

        const availableHeight = Math.max(0, Math.round(mainContentBottom - mainContentTop));
        const contentY = Math.round(mainContentTop);
        const fullWidth = Math.max(0, Math.round(windowWidth));
        const handleWidth = 4;

        if (this.activeTab === 'view') {
            window.electronAPI.setBrowserViewBounds('view', {
                x: 0,
                y: contentY,
                width: fullWidth,
                height: availableHeight
            });
            window.electronAPI.setBrowserViewBounds('editor', { x: 0, y: 0, width: 0, height: 0 });
        } else if (this.activeTab === 'editor') {
            window.electronAPI.setBrowserViewBounds('editor', {
                x: 0,
                y: contentY,
                width: fullWidth,
                height: availableHeight
            });
            window.electronAPI.setBrowserViewBounds('view', { x: 0, y: 0, width: 0, height: 0 });
        } else if (this.activeTab === 'split') {
            const editorPaneWidth = Math.max(0, Math.round((windowWidth * this.editorWidth) / 100));
            const viewerPaneX = editorPaneWidth + handleWidth;
            const viewerPaneWidth = Math.max(0, fullWidth - viewerPaneX);

            window.electronAPI.setBrowserViewBounds('editor', {
                x: 0,
                y: contentY,
                width: editorPaneWidth,
                height: availableHeight
            });
            window.electronAPI.setBrowserViewBounds('view', {
                x: viewerPaneX,
                y: contentY,
                width: viewerPaneWidth,
                height: availableHeight
            });
        }
    },
    updateBrowserViewVisibility() {
        window.electronAPI.setBrowserViewVisibility('view', this.activeTab === 'view' || this.activeTab === 'split');
        window.electronAPI.setBrowserViewVisibility('editor', this.activeTab === 'editor' || this.activeTab === 'split');
    },
    async prepareOverlaySnapshots() {
        const capture = async (viewName) => {
            try {
                return await window.electronAPI.captureBrowserViewPage(viewName);
            } catch (error) {
                console.error(`Falha ao capturar ${viewName}:`, error);
                return null;
            }
        };

        if (this.activeTab === 'split') {
            const [editorShot, viewerShot] = await Promise.all([
                capture('editor'),
                capture('view')
            ]);
            this.editorScreenshot = editorShot;
            this.viewerScreenshot = viewerShot;
        } else if (this.activeTab === 'editor') {
            this.editorScreenshot = await capture('editor');
            this.viewerScreenshot = null;
        } else {
            this.viewerScreenshot = await capture('view');
            this.editorScreenshot = null;
        }
    },
    clearOverlaySnapshots() {
        this.viewerScreenshot = null;
        this.editorScreenshot = null;
    },
    async handleOverlayChange(isOpen) {
        const currentSeq = ++this.overlaySequence;

        if (isOpen) {
            await this.prepareOverlaySnapshots();
            if (this.overlaySequence !== currentSeq) {
                return;
            }
            await window.electronAPI.setAllBrowserViewVisibility(false);
        } else {
            await window.electronAPI.setAllBrowserViewVisibility(true);
            if (this.overlaySequence !== currentSeq) {
                return;
            }
            this.clearOverlaySnapshots();
            this.$nextTick(() => this.updateBrowserViewBounds());
        }
    }
}">
<header class="flex items-center justify-between h-16 px-4 bg-surface-dark border-b border-gray-700 shrink-0">
<div class="flex items-center space-x-2">
<svg class="h-6 w-6 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
<h1 class="text-xl font-bold text-text-dark">Documental</h1>
</div>
<div class="flex items-center space-x-2 ml-4">
<button :class="{ 'bg-gray-700 ring-2 ring-primary': activeTab === 'editor', 'hover:bg-gray-700': activeTab !== 'editor' }" @click="activeTab = 'editor'" class="p-2 rounded-full focus:outline-none">
<span :class="{'text-primary': activeTab === 'editor', 'text-muted-dark': activeTab !== 'editor'}" class="material-icons">edit</span>
</button>
<button :class="{ 'bg-gray-700 ring-2 ring-primary': activeTab === 'view', 'hover:bg-gray-700': activeTab !== 'view' }" @click="activeTab = 'view'" class="p-2 rounded-full focus:outline-none">
<span :class="{'text-primary': activeTab === 'view', 'text-muted-dark': activeTab !== 'view'}" class="material-icons">visibility</span>
</button>
<button :class="{ 'bg-gray-700 ring-2 ring-primary': activeTab === 'split', 'hover:bg-gray-700': activeTab !== 'split' }" @click="activeTab = 'split'" class="p-2 rounded-full focus:outline-none">
<span :class="{'text-primary': activeTab === 'split', 'text-muted-dark': activeTab !== 'split'}" class="material-icons">vertical_split</span>
</button>
</div>
<div class="flex-1 mx-4">
<div class="relative flex items-center">
<div class="flex w-full items-center bg-background-dark border border-gray-600 rounded-md transition-colors">
<div class="flex items-center pl-2 pr-1 space-x-1">
<button @click.prevent="browserGoBack()" class="w-7 h-7 flex items-center justify-center rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary/20" aria-label="Voltar">
<span class="material-icons text-muted-dark text-sm">arrow_back</span>
</button>
<button @click.prevent="browserReload()" class="w-7 h-7 flex items-center justify-center rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary/20" aria-label="Recarregar">
<span class="material-icons text-muted-dark text-sm">refresh</span>
</button>
<button @click.prevent="browserGoHome()" class="w-7 h-7 flex items-center justify-center rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary/20" aria-label="PÃ¡gina inicial">
<span class="material-icons text-muted-dark text-sm">home</span>
</button>
</div>
<div class="flex items-center flex-1 px-2 space-x-2">
<span class="material-icons text-muted-dark text-base">link</span>
<input :disabled="activeTab === 'editor'" @click="handleAddressClick($event)" @input="handleAddressInput($event)" @keydown="handleAddressKeyDown($event)" @keydown.enter="handleAddressEnter($event)" class="flex-1 bg-transparent py-2 text-sm text-text-dark placeholder-muted-dark focus:outline-none focus:ring-0 border-0 disabled:opacity-50 disabled:cursor-not-allowed" type="text" x-model="addressValue"/>
</div>
<button @click.prevent="copyAddress()" class="px-2 h-10 flex items-center text-muted-dark hover:text-text-dark focus:outline-none" aria-label="Copiar endereÃ§o">
<span class="material-icons" x-show="!copySuccess">content_copy</span>
<span class="material-icons text-primary" style="display: none;" x-show="copySuccess">check</span>
</button>
</div>
</div>
</div>
<div class="flex items-center space-x-2">
<button @click="updateModalOpen = true" class="px-4 py-2 text-sm font-semibold text-white bg-accent-orange rounded-md hover:bg-orange-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background-dark focus:ring-accent-orange" :disabled="pullLoading">
                <span x-show="!pullLoading">Atualizar</span>
                <span x-show="pullLoading" class="flex items-center">
                    <div class="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
                    Atualizando...
                </span>
            </button>
<button @click="publishModalOpen = true" class="px-4 py-2 text-sm font-semibold text-white bg-primary rounded-md hover:bg-green-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background-dark focus:ring-primary" :disabled="pushLoading">
                <span x-show="!pushLoading">Publicar</span>
                <span x-show="pushLoading" class="flex items-center">
                    <div class="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
                    Publicando...
                </span>
            </button>
<div class="relative">
<button @click="menuOpen = !menuOpen" class="p-2 rounded-full hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-primary">
<span class="material-icons text-muted-dark">menu</span>
</button>
</div>
</div>
</header>
<div class="flex flex-col flex-1 overflow-hidden" x-ref="mainContainer">
<main :style="{ height: consoleOpen ? mainHeight + '%' : '100%' }" class="flex-1 flex overflow-hidden relative">
    <!-- Placeholder for BrowserViews, which are managed by the main process -->
    <div class="w-full h-full absolute inset-0 pointer-events-none"></div>

    <!-- Initial Loading State -->
    <div x-cloak x-show="initialLoading || clearingCache" 
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="absolute inset-0 z-30 flex flex-col items-center justify-center space-y-4 bg-background-dark">
        <div class="initial-loader">
            <span class="initial-loader__dot"></span>
            <span class="initial-loader__dot"></span>
            <span class="initial-loader__dot"></span>
        </div>
        <p class="text-xs uppercase tracking-[0.3em] text-muted-dark" x-text="clearingCache ? 'limpando cache...' : 'carregando ambiente'"></p>
    </div>

    <!-- Content Loading State -->
    <div x-cloak x-show="contentLoading" 
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-500"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="absolute inset-0 z-20 flex flex-col items-center justify-center space-y-4 bg-background-dark">
        <div class="content-loader">
            <div class="w-16 h-16 border-4 border-gray-600 border-t-primary rounded-full animate-spin"></div>
        </div>
        <p class="text-xs uppercase tracking-[0.3em] text-muted-dark">preparando conteÃºdo</p>
    </div>

    <!-- Content Ready State (fade out) -->
    <div x-cloak x-show="contentReady" 
         x-transition:enter="transition ease-out duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-300"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="absolute inset-0 z-10 flex flex-col items-center justify-center bg-background-dark">
        <div class="text-center">
            <div class="w-12 h-12 mx-auto mb-4 rounded-full bg-primary flex items-center justify-center">
                <span class="material-icons text-white text-xl">check</span>
            </div>
            <p class="text-sm text-text-dark">pronto!</p>
        </div>
    </div>

    <!-- Screenshot overlays for modals/menus -->
    <template x-if="isAnyOverlayOpen">
        <div class="absolute inset-0 pointer-events-none">
            <template x-if="activeTab === 'split'">
                <div class="absolute inset-0 flex">
                    <div class="relative" :style="{ width: editorWidth + '%' }">
                        <template x-if="editorScreenshot">
                            <img :src="editorScreenshot" class="w-full h-full object-cover" alt="Editor preview"/>
                        </template>
                        <div class="absolute inset-0 bg-black bg-opacity-60"></div>
                    </div>
                    <div class="relative flex-1">
                        <template x-if="viewerScreenshot">
                            <img :src="viewerScreenshot" class="w-full h-full object-cover" alt="Viewer preview"/>
                        </template>
                        <div class="absolute inset-0 bg-black bg-opacity-60"></div>
                    </div>
                </div>
            </template>
            <template x-if="activeTab !== 'split'">
                <div class="absolute inset-0 relative">
                    <template x-if="(activeTab === 'view' ? viewerScreenshot : editorScreenshot)">
                        <img :src="activeTab === 'view' ? viewerScreenshot : editorScreenshot" class="w-full h-full object-cover" alt="Browser preview"/>
                    </template>
                    <div class="absolute inset-0 bg-black bg-opacity-60"></div>
                </div>
            </template>
        </div>
    </template>

    <div class="flex w-full h-full absolute inset-0" x-ref="splitContainer" x-show="activeTab === 'split'">
        <div :style="{ width: editorWidth + '%' }" class="h-full overflow-auto pointer-events-none" x-ref="splitEditorPane"></div>
        <div @mousedown.prevent="startResize($event)" class="resize-handle" x-ref="resizeHandle"></div>
        <div class="flex-1 h-full overflow-auto pointer-events-none"></div>
    </div>
</main>
<template x-if="consoleOpen">
<div :style="{ height: `calc(100% - ${mainHeight}%)` }" class="flex flex-col flex-1 bg-surface-dark overflow-hidden shrink-0" x-ref="consoleContainer">
<div @mousedown.prevent="startVerticalResize($event)" class="resize-handle-horizontal w-full" x-ref="resizeHandleHorizontal"></div>
<div class="flex items-center justify-between p-2 border-b border-gray-700">
<div class="flex items-center space-x-1 overflow-x-auto">
<template :key="tab.id" x-for="tab in consoleTabs">
<button :class="{'bg-gray-700 text-primary': activeConsoleTab === tab.id, 'hover:bg-gray-800': activeConsoleTab !== tab.id}" @click="activeConsoleTab = tab.id" class="px-3 py-1 text-sm rounded-md flex items-center space-x-2 shrink-0">
<span x-text="tab.name"></span>
<span @click="closeConsoleTab(tab.id, $event)" class="material-icons text-muted-dark text-xs hover:text-text-dark" x-show="tab.type === 'terminal'">close</span>
</button>
</template>
</div>
<div class="flex items-center space-x-2">

 <button @click="addTerminalTab()" class="p-1 rounded-full hover:bg-gray-700" title="Adicionar terminal" style="display:none;">
 <span class="material-icons text-muted-dark text-base">add</span>
 </button>
<button @click="consoleOpen = false" class="p-1 rounded-full hover:bg-gray-700" title="Fechar console">
<span class="material-icons text-muted-dark text-base">close</span>
</button>
</div>
</div>
<div class="p-4 flex-1 overflow-y-auto font-mono text-sm text-muted-dark" x-ref="consoleContentArea">
<template :key="tab.id" x-for="tab in consoleTabs">
<div x-show="activeConsoleTab === tab.id" x-transition:enter="transition ease-out duration-200" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100">
<div x-show="tab.type === 'log'">
<pre class="text-xs text-muted-dark whitespace-pre-wrap font-mono" x-text="appLogOutput || '(Sem logs de aplicativo)'"></pre>
</div>
<div x-show="tab.type === 'server'">
<pre class="text-xs text-muted-dark whitespace-pre-wrap font-mono" x-text="serverOutput || '(Sem saÃ­da do servidor)'"></pre>
</div>
<div x-show="tab.type === 'commands'">
<pre class="text-xs text-muted-dark whitespace-pre-wrap font-mono" x-text="commandOutput || '(Sem comandos executados)'"></pre>
</div>
<div x-show="tab.type === 'terminal'">
<p class="text-green-400">user@documental:~$ <span class="text-gray-400">Terminal interativo (em desenvolvimento)</span></p>
</div>
</div>
</template>
</div>
</div>
</template>
</div>
<footer class="flex items-center justify-between h-8 px-4 bg-surface-dark border-t border-gray-700 text-xs text-muted-dark shrink-0">
<div class="flex items-center space-x-6">
<button @click="branchModalOpen = true" class="flex items-center space-x-2 hover:text-text-dark">
<span class="material-icons text-sm">drive_file_move</span>
<span class="font-bold" x-text="currentBranch"></span>
</button>
<button @click="openProjectDirectory()" class="flex items-center space-x-2 hover:text-text-dark" :title="repoInfo.workingDirectory || 'Abrir diretÃ³rio do projeto'">
<span class="material-icons text-sm">folder_open</span>
<span class="truncate max-w-xs" x-text="repoInfo.workingDirectory || '/caminho/do/projeto'"></span>
</button>
</div>
<div class="flex items-center space-x-6 flex-1 justify-end">
<a class="flex items-center space-x-2 hover:text-text-dark underline" :href="repoInfo.remoteUrl || '#'" x-show="repoInfo.remoteUrl" target="_blank">
<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" fill-rule="evenodd"></path></svg>
<span x-text="getRepoNameFromUrl(repoInfo.remoteUrl)"></span>
</a>
<a class="flex items-center space-x-2 hover:text-text-dark underline" :href="repoInfo.remoteUrl ? repoInfo.remoteUrl.replace('.git', '') + '/commit/' + repoInfo.lastCommit.hash : '#'" x-show="repoInfo.lastCommit.hash" target="_blank">
<span class="material-icons text-sm">commit</span>
<span x-text="repoInfo.lastCommit.hash"></span>
</a>
<div class="flex items-center space-x-2 max-w-md">
<span class="material-icons text-sm">chat_bubble_outline</span>
<span class="truncate" x-text="repoInfo.lastCommit.message || 'Sem commits'"></span>
<span x-show="repoInfo.lastCommit.date" x-text="'- ' + formatCommitDate(repoInfo.lastCommit.date)" class="ml-2 whitespace-nowrap"></span>
</div>
<button @click="consoleOpen = !consoleOpen; if(consoleOpen) mainHeight = 70;" class="flex items-center space-x-2 hover:text-text-dark" :class="{'text-primary': consoleOpen}" title="Toggle Terminal">
<span class="material-icons text-sm">terminal</span>
</button>
</div>
</footer>
<div @click.outside="menuOpen = false" class="absolute top-16 right-4 z-10" style="display: none;" x-show="menuOpen" x-transition:enter="transition ease-out duration-200" x-transition:enter-end="opacity-100 transform scale-100" x-transition:enter-start="opacity-0 transform scale-95" x-transition:leave="transition ease-in duration-75" x-transition:leave-end="opacity-0 transform scale-95" x-transition:leave-start="opacity-100 transform scale-100">
<div class="w-56 bg-surface-dark rounded-md shadow-lg border border-gray-700">
<nav class="p-2">
<ul class="space-y-1">
  <li>
    <a @click.prevent="consoleOpen = !consoleOpen; if(consoleOpen) mainHeight = 70; menuOpen = false" class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#">
      <span class="material-icons mr-3">terminal</span>
      <span>Console</span>
    </a>
  </li>
  <li>
    <a @click.prevent="clearCacheModalOpen = true" class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#">
      <span class="material-icons mr-3">delete_sweep</span>
      <span>Limpar cache</span>
    </a>
  </li>
  <li>
    <a @click.prevent="openNewWindow()" class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#">
      <span class="material-icons mr-3">open_in_new</span>
      <span>Nova Janela</span>
    </a>
  </li>

  <li class="border-t border-gray-700 my-2"></li>
  <li>
    <a class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#" data-navigate="config.html">
      <span class="material-icons mr-3">settings</span>
      <span>ConfiguraÃ§Ãµes</span>
    </a>
  </li>
  <li>
    <a @click.prevent="helpModalOpen = true" class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#">
      <span class="material-icons mr-3">help_outline</span>
      <span>Ajuda</span>
    </a>
  </li>
  <li>
    <a @click.prevent="aboutModalOpen = true" class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#">
      <span class="material-icons mr-3">info_outline</span>
      <span>Sobre</span>
    </a>
  </li>
  <li class="border-t border-gray-700 my-2"></li>
  <li>
    <a @click.prevent="exitApp()" class="flex items-center px-4 py-2 text-text-dark hover:bg-gray-700 rounded-md" href="#">
      <span class="material-icons mr-3">exit_to_app</span>
      <span>Sair</span>
    </a>
  </li>
</ul>
</nav>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="updateModalOpen">
<div @click.outside="updateModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-md">
<h3 class="text-lg font-medium text-text-dark">Confirmar AtualizaÃ§Ã£o</h3>
<p class="mt-2 text-sm text-muted-dark">VocÃª tem certeza que deseja atualizar a branch '<span class="font-bold text-primary" x-text="currentBranch"></span>'? Isso buscarÃ¡ atualizaÃ§Ãµes da branch remota 'preview' e mesclarÃ¡ na branch atual.</p>
<div class="mt-4 flex justify-end space-x-2">
<button @click="updateModalOpen = false" class="px-4 py-2 text-sm font-medium text-muted-dark bg-gray-700 rounded-md hover:bg-gray-600" :disabled="pullLoading">Cancelar</button>
<button @click="pullFromPreview()" class="px-4 py-2 text-sm font-medium text-white bg-accent-orange rounded-md hover:bg-orange-500" :disabled="pullLoading">
<span x-show="!pullLoading">Atualizar</span>
<span x-show="pullLoading" class="flex items-center">
<div class="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
Atualizando...
</span>
</button>
</div>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="publishModalOpen">
<div @click.outside="publishModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-lg">
<h3 class="text-lg font-medium text-text-dark">Publicar AlteraÃ§Ãµes</h3>
<p class="mt-2 text-sm text-muted-dark">Selecione a branch para publicar.</p>
<div class="mt-4 space-y-4">
<div>
<label class="text-sm font-medium text-text-dark">Selecionar branch remota</label>
<div class="mt-1 relative">
<select class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-600 bg-background-dark focus:outline-none focus:ring-primary focus:border-primary sm:text-sm rounded-md text-text-dark" x-model="selectedPublishBranch" :disabled="pushLoading || remoteBranches.length === 0">
<template x-for="branch in remoteBranches" :key="branch">
<option :value="branch" x-text="branch" :selected="branch === selectedPublishBranch"></option>
</template>
</select>
<div x-show="pushLoading || remoteBranches.length === 0" class="absolute inset-0 flex items-center justify-center bg-background-dark bg-opacity-75">
<div x-show="pushLoading" class="w-4 h-4 border-2 border-gray-600 border-t-primary rounded-full animate-spin"></div>
<span x-show="!pushLoading && remoteBranches.length === 0" class="text-xs text-muted-dark">Carregando branches...</span>
</div>
</div>
<p class="mt-1 text-xs text-muted-dark">A branch '<span class="font-bold text-primary" x-text="currentBranch"></span>' serÃ¡ publicada para a branch selecionada.</p>
</div>
</div>
<div class="mt-6 flex justify-end space-x-2">
<button @click="publishModalOpen = false" class="px-4 py-2 text-sm font-medium text-muted-dark bg-gray-700 rounded-md hover:bg-gray-600" :disabled="pushLoading">Cancelar</button>
<button @click="pushToBranch()" class="px-4 py-2 text-sm font-medium text-white bg-primary rounded-md hover:bg-green-500" :disabled="pushLoading || !selectedPublishBranch">
<span x-show="!pushLoading">Publicar</span>
<span x-show="pushLoading" class="flex items-center">
<div class="w-3 h-3 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
Publicando...
</span>
</button>
</div>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="branchModalOpen">
<div @click.outside="branchModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-lg">
<h3 class="text-lg font-medium text-text-dark">Gerenciar Branches</h3>
<p class="mt-2 text-sm text-muted-dark">Selecione uma branch existente ou crie uma nova branch local.</p>
<div class="mt-4 space-y-4">
<div>
<label class="text-sm font-medium text-text-dark">Branch Atual</label>
<p class="mt-1 text-primary font-bold" x-text="currentBranch"></p>
</div>
<div>
<label class="text-sm font-medium text-text-dark">AÃ§Ã£o</label>
<select class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-600 bg-background-dark focus:outline-none focus:ring-primary focus:border-primary sm:text-sm rounded-md text-text-dark" x-model="branchAction">
<option value="change">Mudar para branch existente</option>
<option value="create">Criar nova branch local</option>
</select>
</div>
<div x-show="branchAction === 'change'">
<label class="text-sm font-medium text-text-dark">Mudar para branch</label>
<div class="mt-1 relative">
<select class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-600 bg-background-dark focus:outline-none focus:ring-primary focus:border-primary sm:text-sm rounded-md text-text-dark" x-model="selectedBranch" :disabled="branchLoading">
<template x-for="branch in branches" :key="branch.name">
<option :value="branch.name" x-text="branch.name"></option>
</template>
</select>
<!-- Debug info -->
<div x-show="branches.length === 0" class="text-red-500 text-sm mt-2">
ðŸ” DEBUG: No branches found. 
<br>branches.length: <span x-text="branches.length"></span>
<br>branchLoading: <span x-text="branchLoading"></span>
<br>currentBranch: <span x-text="currentBranch"></span>
</div>
<div x-show="branches.length > 0" class="text-green-500 text-sm mt-2">
âœ… DEBUG: Found <span x-text="branches.length"></span> branches
</div>
<div x-show="branchLoading" class="absolute inset-0 flex items-center justify-center bg-background-dark bg-opacity-75">
<div class="w-4 h-4 border-2 border-gray-600 border-t-primary rounded-full animate-spin"></div>
</div>
</div>
</div>
<div x-show="branchAction === 'create'">
<label class="block text-sm font-medium text-text-dark" for="new-branch-name">Nome da nova branch</label>
<div class="mt-1 flex rounded-md shadow-sm">
<span class="inline-flex items-center px-3 rounded-l-md border border-r-0 border-gray-600 bg-gray-700 text-muted-dark text-sm" x-text="getWorkingBranchName()"></span>
<input class="flex-1 block w-full rounded-none rounded-r-md bg-background-dark border-gray-600 focus:ring-primary focus:border-primary sm:text-sm text-text-dark" id="new-branch-name" placeholder="adicione-um-sufixo-aqui" type="text" x-model="newBranchName"/>
</div>
</div>
</div>
<div class="mt-6 flex justify-end space-x-2">
<button @click="branchModalOpen = false" class="px-4 py-2 text-sm font-medium text-muted-dark bg-gray-700 rounded-md hover:bg-gray-600">Cancelar</button>
<button @click="changeBranch(); branchModalOpen = false;" class="px-4 py-2 text-sm font-medium text-white bg-primary rounded-md hover:bg-green-500" x-show="branchAction === 'change'" :disabled="branchLoading || selectedBranch === currentBranch">Mudar Branch</button>
<button @click="createBranch(); branchModalOpen = false;" class="px-4 py-2 text-sm font-medium text-white bg-primary rounded-md hover:bg-green-500" x-show="branchAction === 'create'" :disabled="branchLoading || !newBranchName.trim()">Criar Branch</button>
</div>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="clearCacheModalOpen">
<div @click.outside="clearCacheModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-md">
<h3 class="text-lg font-medium text-text-dark">Limpar Cache</h3>
<p class="mt-2 text-sm text-muted-dark">Tem certeza de que deseja limpar o cache? Todos os dados de histÃ³rico, cache e cookies serÃ£o perdidos definitivamente. Esta aÃ§Ã£o nÃ£o pode ser desfeita.</p>
<div class="mt-4 flex justify-end space-x-2">
<button @click="clearCacheModalOpen = false" class="px-4 py-2 text-sm font-medium text-muted-dark bg-gray-700 rounded-md hover:bg-gray-600">Cancelar</button>
<button @click="confirmClearCache()" class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-500">Limpar</button>
</div>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="helpModalOpen">
<div @click.outside="helpModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-lg">
<h3 class="text-lg font-medium text-text-dark">Ajuda</h3>
<div class="mt-2 space-y-4 text-sm text-muted-dark">
<p>Bem-vindo ao Documental Desktop! Aqui estÃ£o algumas dicas para comeÃ§ar:</p>
<ul class="list-disc list-inside space-y-2">
<li>Use os botÃµes <span class="material-icons text-xs align-middle">edit</span>, <span class="material-icons text-xs align-middle">visibility</span>, e <span class="material-icons text-xs align-middle">vertical_split</span> para alternar entre os modos de visualizaÃ§Ã£o.</li>
<li>A barra de endereÃ§o permite que vocÃª navegue para diferentes pÃ¡ginas do seu projeto.</li>
<li>Use o menu <span class="material-icons text-xs align-middle">menu</span> para acessar mais opÃ§Ãµes como o Console e ConfiguraÃ§Ãµes.</li>
<li>A barra inferior mostra informaÃ§Ãµes Ãºteis sobre o seu projeto Git.</li>
</ul>
<p>Para mais informaÃ§Ãµes, visite nossa <a class="text-primary hover:underline" href="#">documentaÃ§Ã£o online</a>.</p>
</div>
<div class="mt-6 flex justify-end">
<button @click="helpModalOpen = false" class="px-4 py-2 text-sm font-medium text-white bg-primary rounded-md hover:bg-green-500">Entendido</button>
</div>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="aboutModalOpen">
<div @click.outside="aboutModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-md text-center">
<div class="flex justify-center mb-4">
<svg class="h-12 w-12 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"></path>
</svg>
</div>
<h3 class="text-lg font-medium text-text-dark">Documental Desktop</h3>
<p class="mt-1 text-sm text-muted-dark">VersÃ£o 1.0.0 (Electron)</p>
<p class="mt-4 text-xs text-muted-dark">Â© 2023 Documental. Todos os direitos reservados.</p>
<div class="mt-6 flex justify-center">
<button @click="aboutModalOpen = false" class="px-4 py-2 text-sm font-medium text-white bg-primary rounded-md hover:bg-green-500">Fechar</button>
</div>
</div>
</div>
<div class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50" style="display: none;" x-show="exitModalOpen">
<div @click.outside="exitModalOpen = false" class="bg-surface-dark rounded-lg shadow-xl p-6 w-full max-w-md">
<h3 class="text-lg font-medium text-text-dark">Sair do Documental</h3>
<p class="mt-2 text-sm text-muted-dark">Tem certeza de que deseja sair do aplicativo?</p>
<div class="mt-4 flex justify-end space-x-2">
    <button @click="cancelExit()" class="px-4 py-2 text-sm font-medium text-muted-dark bg-gray-700 rounded-md hover:bg-gray-600">Cancelar</button>
    <button @click="confirmExit()" class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-500">Sair</button>
</div>
</div>
</div>
</div>

</body></html>
